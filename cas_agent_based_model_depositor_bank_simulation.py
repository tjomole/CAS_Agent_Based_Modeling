# -*- coding: utf-8 -*-
"""CAS_Agent-Based-Model_Depositor-Bank_Simulation.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1mYAy83g21DR3iwtF4uqkc8vodVLKuXd-

#CAS_Agent-Based-Model_Depositor-Bank_Simulation

###Project Rationale:

Covers a review of what, why and who will use the system.
The model can help to gain an informed understanding of the complex interactions between.

###Domain Review – Context & Background:

At a micro-level, the SVB’s failure is shown as an example of a dimension of the banking industry being a Complex System: small change(s) in some drivers -> much bigger system-level impacts.

###Model Features & Key Considerations:

Covers the environment chosen – open, the description of agents and their attributes.
Behavior of the key elements, and the procedures underlying the simulation to considered.

###Model Design and Results:

Some emergent properties at the aggregate / banking sector level will be highlighted.
The impact of bank stability factor, used by depositors to calibrate their risk-aversion coefficient, on the share of the wallet deposited at system-wide level, will be observed.

This model utilizes object-oriented programming to define the agents and their behaviors. For visualization purposes, the matplotlib library is employed to represent depositors with colors based on their monetary holdings.

##Libraries
"""

! pip install matplotlib numpy

"""### Load relevant packages"""

import random
import matplotlib.pyplot as plt
import matplotlib.colors as mcolors
import numpy as np

# Constants
NUM_DEPOSITORS = 20
NUM_BANKS = 5
INITIAL_MONEY = 1000
TIME_STEPS = 100  # Define the number of iterations
SUMMARY_INTERVAL = 10  # Interval for recording summary

# Generate a unique color for each depositor
DEPOSITOR_COLORS = list(mcolors.TABLEAU_COLORS.values()) + list(mcolors.CSS4_COLORS.values())[:NUM_DEPOSITORS - len(mcolors.TABLEAU_COLORS)]

class Bank:
    def __init__(self, bank_id):
        self.bank_id = bank_id
        self.deposit_interest_rate = random.uniform(0.01, 0.05)  # 1% to 5%
        self.stability = random.uniform(0, 100)
        self.total_deposits = 0
        self.deposits = {}  # Depositor ID to amount

    def update_parameters(self):
        self.deposit_interest_rate = random.uniform(0.01, 0.05)
        self.stability = random.uniform(0, 100)

    def accept_deposit(self, depositor_id, amount):
        self.total_deposits += amount
        if depositor_id in self.deposits:
            self.deposits[depositor_id] += amount
        else:
            self.deposits[depositor_id] = amount

    def honor_withdrawal(self, depositor_id, amount):
        if depositor_id in self.deposits and self.deposits[depositor_id] >= amount:
            self.deposits[depositor_id] -= amount
            self.total_deposits -= amount
            return amount
        return 0

class Depositor:
    def __init__(self, depositor_id):
        self.depositor_id = depositor_id
        self.money = INITIAL_MONEY
        self.color = DEPOSITOR_COLORS[depositor_id]

    def decide_action(self, banks):
        actions = []
        for bank in banks:
            score = (bank.deposit_interest_rate * 100) + bank.stability
            actions.append(score)
        total = sum(actions)
        probabilities = [a / total for a in actions]
        chosen_bank = np.random.choice(banks, p=probabilities)
        return chosen_bank

    def deposit(self, bank, amount):
        if self.money >= amount:
            bank.accept_deposit(self.depositor_id, amount)
            self.money -= amount

    def withdraw(self, bank, amount):
        withdrawn = bank.honor_withdrawal(self.depositor_id, amount)
        self.money += withdrawn

def visualize(depositors, banks, interactions, time_step):
    fig, ax = plt.subplots(figsize=(14, 8))

    # Plot depositors
    for depositor in depositors:
        ax.scatter(depositor.depositor_id, 1, color=depositor.color, s=100, label=f'Depositor {depositor.depositor_id + 1}')

    # Plot banks and spread them out and centered
    bank_positions = np.linspace(0, NUM_DEPOSITORS - 1, NUM_BANKS)
    for i, bank in enumerate(banks):
        normalized_stability = bank.stability / 100
        cmap = plt.cm.Blues
        color = cmap(normalized_stability)
        ax.scatter(bank_positions[i], 0, color=color, s=800, marker='s', label=f'Bank {bank.bank_id + 1}')

    # Add arrows for interactions
    for depositor_id, bank_id, action in interactions:
        depositor_x = depositor_id
        bank_x = bank_positions[bank_id]
        if action == 'deposit':
            ax.annotate("", xy=(bank_x, 0), xytext=(depositor_x, 1),
                        arrowprops=dict(facecolor='green', edgecolor='green', shrinkA=5, shrinkB=5, headwidth=5, width=0.5))
        elif action == 'withdraw':
            ax.annotate("", xy=(depositor_x, 1), xytext=(bank_x, 0),
                        arrowprops=dict(facecolor='red', edgecolor='red', shrinkA=5, shrinkB=5, headwidth=5, width=0.5))

    ax.set_xlim(-1, NUM_DEPOSITORS)
    ax.set_ylim(-0.5, 1.5)
    ax.set_xticks(range(NUM_DEPOSITORS))
    ax.set_yticks([0, 1])
    ax.set_yticklabels(['Banks', 'Depositors'])
    ax.set_title(f'Banking System at Time Step {time_step}')
    ax.legend(loc='upper right', bbox_to_anchor=(1.15, 1), fontsize='small', ncol=2)

    plt.show()

def main():
    # Initialize banks and depositors
    banks = [Bank(bank_id=i) for i in range(NUM_BANKS)]
    depositors = [Depositor(depositor_id=i) for i in range(NUM_DEPOSITORS)]

    # Prepare a summary list to store total deposits at each bank after every 10 iterations
    summary_table = []

    for time_step in range(1, TIME_STEPS + 1):
        print(f'\n--- Time Step {time_step} ---')

        # Update bank parameters
        for bank in banks:
            bank.update_parameters()
            print(f'Bank {bank.bank_id}: Interest Rate = {bank.deposit_interest_rate:.2%}, Stability = {bank.stability:.2f}')

        # Record interactions for visualization
        interactions = []

        # Each depositor decides to deposit or withdraw
        for depositor in depositors:
            action = random.choice(['deposit', 'withdraw'])
            chosen_bank = depositor.decide_action(banks)
            if action == 'deposit':
                amount = random.uniform(1, depositor.money) if depositor.money > 0 else 0
                depositor.deposit(chosen_bank, amount)
                print(f'Depositor {depositor.depositor_id + 1} deposited ${amount:.2f} to Bank {chosen_bank.bank_id + 1}')
                interactions.append((depositor.depositor_id, chosen_bank.bank_id, 'deposit'))
            elif action == 'withdraw':
                deposited_amount = chosen_bank.deposits.get(depositor.depositor_id, 0)
                amount = random.uniform(1, deposited_amount) if deposited_amount > 0 else 0
                if amount > 0:
                    depositor.withdraw(chosen_bank, amount)
                    print(f'Depositor {depositor.depositor_id + 1} withdrew ${amount:.2f} from Bank {chosen_bank.bank_id + 1}')
                    interactions.append((depositor.depositor_id, chosen_bank.bank_id, 'withdraw'))

        # Visualization after each time step
        visualize(depositors, banks, interactions, time_step)

        # Record the total deposits at each bank every 10 iterations
        if time_step % SUMMARY_INTERVAL == 0:
            summary_table.append([time_step] + [bank.total_deposits for bank in banks])

    # Print summary table at the end of all iterations
    print("\nSummary of Total Deposits at Each Bank After Every 10 Iterations:")
    headers = ["Time Step"] + [f"Bank {i+1}" for i in range(NUM_BANKS)]
    print("{:<10} {:<10} {:<10} {:<10} {:<10} {:<10}".format(*headers))
    for row in summary_table:
        print("{:<10} {:<10.2f} {:<10.2f} {:<10.2f} {:<10.2f} {:<10.2f}".format(*row))

if __name__ == "__main__":
    main()

"""## Notes


This implementation provides a foundational framework for simulating the interactions between depositors and banks within a banking system.

It can be further enhanced by incorporating more sophisticated decision-making algorithms, integrating deep learning models for predictive analytics, or expanding the visualization for more detailed insights.

### Overview:

####Depositor Colors:
Each of the 20 depositors is represented by a unique color from matplotlib's TABLEAU_COLORS. The DEPOSITOR_COLORS list is expanded to accommodate 20 unique colors. Colors from TABLEAU_COLORS is expanded with a subset of colors from CSS4_COLORS to ensure there are enough colors for all depositors.

These colors are consistent throughout the simulation and help visually distinguish each depositor.

####Bank Visualization:
The banks are visualized as squares ('s' marker), with their colors representing stability.

A lighter blue shade indicates lower stability, and a darker blue shade indicates higher stability.

####Visualization Method:
The visualize function plots the depositors and banks. Depositors are plotted along the y-axis at y=1, while banks are plotted at y=0.

Each depositor has a consistent color, and the banks change color each time step according to their stability.

####Scatter Plot:
The plot is divided into two rows: the first row represents depositors, and the second row represents banks.

The depositor's unique color remains constant, while the bank's color varies according to the stability value in each iteration.

###The End###
"""